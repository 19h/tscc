/**
 * @fileoverview Decorators in TS is not compatible with Closure Compiler, as it generates
 * code that access a class' prototype property by string literals.
 * decoratorPropertyTransformer lookup occurence of such string literal property names,
 * and replaces it with appropriate `goog.reflect.objectProperty(<prop_name>, <target>)` call.
 * 
 * Tsickle may at some point implement a similar feature. Currently it only implements some
 * other kinds of tranformation that is only made to make Angular work.
 *
 * Usage of goog.reflect.objectProperty is based on the following article:
 * {@link http://closuretools.blogspot.com/2016/06/using-polymer-with-closure-compiler-part-2.html}.
 *
 * In addition, we have to prevent this DevirtualizeMethods pass of closure compiler. However, there is
 * seem to be no stable way; see
 * nocollapse does not work - {@link https://github.com/google/closure-compiler/issues/2420}
 * sinkValue prevents inlining but does not prevent devirtualization
 * {@link https://github.com/google/closure-compiler/issues/2599}
 * 
 * The pass is prevented when the property is accessed in a global scope, so we are creating
 * aaccesses of those and remove those via regex replace after the compilation. This is hacky and
 * not guaranteed to work but was the only way to make this work. Also has to be careful about
 * accessor decorators.
 */

import * as ts from 'typescript';
import {TsickleHost} from 'tsickle';
import {isVariableRequireStatement, createGoogCall} from './transformer_utils'


function findImportedVariable(sf: ts.SourceFile, moduleName: string): ts.Identifier {
	for (let stmt of sf.statements) {
		let _ = isVariableRequireStatement(stmt);
		if (!_) continue;
		if (_.importedUrl !== moduleName) continue;
		return _.newIdent
	}
}
/**
 * The transformer needs to discern "tslib" function calls (called EmitHelpers in TS),
 * but they are simply identifiers of name `__decorate` and such, all the difference
 * lies in their `emitNode` internal property. Any functionality related to this is
 * under internal and is not available in public API.
 * This function currently access Node.emitNode.flags to achieve this
 */
function identifierIsEmitHelper(ident: ts.Identifier): boolean {
	let emitNode = ident["emitNode"];
	if (emitNode === undefined) return false;
	let flags = emitNode["flags"];
	if (typeof flags !== "number") return false;
	return (flags & ts.EmitFlags.HelperName) !== 0;
}

export default function decoratorPropertyTransformer(tsickleHost: TsickleHost):
	(context: ts.TransformationContext) => ts.Transformer<ts.SourceFile> {
	return (context: ts.TransformationContext) => {
		return (sf: ts.SourceFile) => {
			// There's nothing to do when tslib was not imported to the module.
			if (!findImportedVariable(sf, 'tslib')) return sf;
			const existingGoogReflectImport = findImportedVariable(sf, 'goog:goog.reflect');
			const googReflectImport =
				existingGoogReflectImport ||
				ts.createIdentifier(`tscc_goog_reflect_injected`);
			const annotatedPropertyAccesses: ts.Statement[] = [];
			const getId = (() => {
				let counter = 1;
				return () => `tscc_global_access_name_${counter++}`
			})();
			/**
			 * Queries whether this expression is 
			 * `tslib_1.__decorate([decorators], target, prop, descriptor)`
			 * that is generated by the TS compiler, and if so, returns a new node
			 * for __decoratr(..., goog.reflect.objectProperty(prop, target), descriptor).
			 */
			const maybeTsGeneratedDecorateCall = (node: ts.Node): ts.Node => {
				if (!ts.isCallExpression(node)) return;
				const caller = node.expression;

				if (!ts.isIdentifier(caller)) return;
				if (caller.escapedText !== ts.escapeLeadingUnderscores('__decorate')) return;
				if (!identifierIsEmitHelper(caller)) return;
				// Found a candidate. Decorator helper call signature:
				// __decorate([decoratorsArray], <target>, <propertyName>, <desc>)
				let propNameLiteral = node.arguments[2];
				if (!ts.isStringLiteral(propNameLiteral)) return;
				let propName = propNameLiteral.text;

				// Create goog.reflect.objectProperty
				const target = node.arguments[1];
				const googReflectObjectProperty = ts.setTextRange(
					ts.createCall(
						ts.createPropertyAccess(
							googReflectImport,
							ts.createIdentifier('objectProperty')
						),
						undefined,
						[
							ts.createStringLiteral(propName),
							ts.getMutableClone(target)
						]
					),
					propNameLiteral
				);
				const newCallExpression = ts.createCall(
					caller, undefined, [
						node.arguments[0],
						node.arguments[1],
						googReflectObjectProperty,
						node.arguments[3]
					]
				);
				// We will create a if (false) block at the end to annotate these properties
				// with @nocollapse.
				const propertyAccess =
					ts.createPropertyAccess(
						ts.createParen(ts.getMutableClone(target)),
						ts.createIdentifier(propName)
					)
				// Annotate it
				ts.setSyntheticLeadingComments(propertyAccess, [{
					kind: ts.SyntaxKind.MultiLineCommentTrivia,
					text: "* @nocollapase ",
					pos: -1,
					end: -1,
					hasTrailingNewLine: false
				}])
				const binaryExpression = ts.createBinary(
					ts.createElementAccess(
						ts.createIdentifier("self"),
						ts.createStringLiteral(getId())
					),
					ts.createToken(ts.SyntaxKind.FirstAssignment),
					ts.createPropertyAccess(
						ts.createParen(ts.getMutableClone(target)),
						ts.createIdentifier(propName)
					)
				);
				annotatedPropertyAccesses.push(ts.createExpressionStatement(binaryExpression));
				return newCallExpression;
			};
			let foundTransformedDecorateCall = false;
			const visitor = (node: ts.Node): ts.Node => {
				let transformed = maybeTsGeneratedDecorateCall(node);
				if (transformed) {
					foundTransformedDecorateCall = true;
					return transformed;
				}
				return ts.visitEachChild(node, visitor, context);
			}
			const newSf = visitor(sf) as ts.SourceFile;
			if (!foundTransformedDecorateCall) return newSf;
			const requireReflect = ts.createVariableStatement(
				undefined,
				ts.createVariableDeclarationList(
					[
						ts.createVariableDeclaration(
							googReflectImport,
							undefined,
							createGoogCall("require", ts.createStringLiteral('goog.reflect'))
						)
					],
					tsickleHost.es5Mode ? undefined : ts.NodeFlags.Const)
			)
			const stmts = newSf.statements.slice();
			stmts.unshift(requireReflect);
			stmts.push(
				ts.createExpressionStatement(ts.createStringLiteral("__tscc_export_start__")),
				ts.createBlock(annotatedPropertyAccesses),
				ts.createExpressionStatement(ts.createStringLiteral('__tscc_export_end__'))
			);
			return ts.updateSourceFileNode(newSf, ts.setTextRange(ts.createNodeArray(stmts), newSf.statements));
		};
	};
}

